# 统计信息文档
## 方案
添加关键字analyze，采样统计一张表，采用蓄水池抽样法进行采样，使用列等深直方图，然后将这些采样信息保存到要给统计表中`relstatistics`。  
目前先准备整型统计。

## 原理
蓄水池采样法解决的是从一个大数据量 N 中抽取出 M 个不重复的数据，例如从 100000 份调查报告中抽取 1000 份进行统计。它能够在只遍历一次数据的情况下，随机抽取出指定数量的不重复数据  
蓄水池采样法的流程如下  

- 假设数据序列的规模为 n，需要抽取的数量为 m。  
- 首先构建一个容量为 m 的蓄水池数组，将序列的前 m 个元素放入蓄水池中。  
- 对于之后的元素，假设该元素为第 i 个（i >= m），在 [0, i] 中取得随机数 a，若 a 落在 [0, m-1] 范围内，那么该元素替换掉原来蓄水池中的第 a 个元素。  
- 在遍历完数据序列后，蓄水池中剩下的元素即为要抽取的样本  

其证明方法如下：

- 当 i < m 时，元素进入水池的概率为 1，这个不难理解，下面看元素不被替换的概率，当遍历到第 m 个元素时，替换池中元素的概率为 m/(m+1)，池中第 i 个元素被替换的概率为 1/m，所以总的来说，遍历到第 m 个元素时，第 i 个元素不被替换的概率为 1 - (m/(m+1) 1/m) = m/(m+1)。依次类推，当遍历到第 j 个元素时（j >= m），第 i 个元素不被替换的概率为 j/(j+1)。所以当遍历完 n 个元素时，第 i 个元素不被替换的概率为 m/(m+1) (m+1)/(m+2) … (n-1)/n = m/n。总的来说，当 i < m 时，第 i 个元素被抽取到的概率为 1 m/n = m/n。  
- 当 i >= m 时，在 [0, i] 中抽取随机数 d，如果 d < m，则替换掉池中的第 d 个元素，所以此时元素可以进入水池的概率为 m/(i+1)。元素进入到蓄水池后，由上面的证明可以得知，元素不被替换掉的概率为 (i+1)/n。所以总的来说，当 i >= m 时，第 i 个元素被抽取到的概率为 m/(i+1) * (i+1)/n = m/n。  

综上，可知遍历完一遍后，所以元素被抽取到的概率都为 m/n，即抽样是公平的。

## 流程

- 选择数据库
  - 检查当前数据库下时候有统计信息表`relstatistics`，如果没有，则创建表（调用`SM_Manager::CreateTable`）。  

    | 属性 | 类型 | 名字 |
    | -- | -- | -- |
    | 表名 | char(MAXNAME + 1) | relname |
    | 字段名 | char(MAXNAME + 1) | attrname |
    | 桶的个数 | int(5) | bucketnum |
    | 统计信息 | char(100,000) | value |

- 选择要分析的表
  - 检查表是否存在
  - 使用`SM_Manager::GetRelEntry`来获取元组数
  - 打开表，创建一个全表扫描的迭代器（仿照`QL:Manager::Select`流程）
  - 蓄水池采样，采样个数 = ceil(元组数 / 100)（待定，可能用一个map来记录，参考`mimalloc`的`bin`）
  - 使用`SM_Manager::GetDataAttrInfo`来获取属性列
  - 直方图的桶个数 = ceil(采样个数 / 20) (待定)
  - 各个整型字段排序，等深放入到桶中。
    - 如果 V 等于上一个值，那么把 V 放在与上一个值同一个桶里，无论桶是不是已经满，这样可以保证每个值只存在于一个桶中。 
    - 如果不等于，那么判断当前桶是否已经满，如果不是的话，就直接放入当前桶，否则的话，就放入下一个桶。
  - 查看统计表中是否有该表的统计信息
    - 如果没有，将桶的值范围写入到表中（仿照`QL_Manager::Insert`）
    - 如果有，则更新（`QL_Manager::Update`）
    - 实际写代码的时候，考虑到Delete也是全表扫描，就暴力了些，直接先删除再插入了

## 使用方法
在选择数据库之后，执行 `analyze table tablename;`即可对表取样，并将结果保存在`relstatistics`表中，使用`select * from relstatistics;`即可查到采样信息。  

## 引用
[TiDB 源码阅读系列文章（十二）统计信息（上）](https://cn.pingcap.com/blog/tidb-source-code-reading-12)  
[sample.go](https://github.com/pingcap/tidb/blob/5cc1c3b39eef1596d9432fe5db74ee02b83be46b/statistics/sample.go#L168)

## 问题 & 优化
- [ ] 一条记录最大是`4096 - sizeof(int)`导致了统计信息的长度受限，也就是对桶的数量有限制。考虑查表的方式，根据元组数来调整桶的个数
- [ ] 单独一个程序虽然也是往数据库中插入记录，但是要想数据库正常使用，可能需要重启数据库，因为有buffer，有不一致的问题。或者有命令可以让数据库清空buffer。可能会考虑添加关键字，先尝试一下

